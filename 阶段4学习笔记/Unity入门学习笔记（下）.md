## 学习背景

* 制作**[Ruby's Adventure](https://www.sikiedu.com/my/course/650)**，过程中注意学习以下内容

1. 了解unity工程面板
2. 组件的概念与理解
3. 物体的物理系统
4. 动画系统，粒子系统，Cinemachine工具包
5. 敌人AI的制作
6. UGUI
7. 完整游戏流程梳理

## 目录

Cinemachine工具包

粒子系统

UGUI

NPC对话

音乐与音效添加

打包

## 学习内容

### 1.Cinemachine工具包

包是一组代码和资产，可以使用包管理器添加到项目中。它们将功能添加到项目中，这样开发者就不必自己编写代码，例如虚拟现实支持、后期处理效果等等。可以在右上角`Window > Package Manager`里添加项目中需要使用到的工具包。

`Cinemachine`工具包可以快速创建复杂的相机设置，允许在多个相机之间移动，跟随和剪切。

摄像机的投影模式：

* 透视（Perspective）：所有离开相机的线都会聚到一个点上，当它们离相机越远时，使物体看起来越小。

* 正交（Orthographic）：所有平行线保持平行的地方。

为规定摄像机边界，可以给地形做一个碰撞器边界

在CMvcanm里的cinemachineCOnfiner中的Boundingshape2D设置一个带有PolygonConllider2D或是CompositeCollider2D的碰撞器的空游戏对象。

这样可以避免玩家移动时看到地图外部。

### 2.粒子系统

粒子在交互应用中广泛用于效果。粒子系统会产生几十个甚至几百个粒子，这些粒子是具有方向、速度、寿命、颜色和许多其他特性的小图像。通过使用所有这些参数，粒子可以集体创建诸如烟雾、火花甚至火焰之类的效果。

在`Hierachy`窗口中右键点击`Effect>ParticleSystem`可创建粒子系统。

如果想要粒子系统使用精灵图片资源，则需要勾选SheetAnimation，且将模式改为Sprites。

如果想要在多个图片资源中随机产生则需要将StartFrame选项的Constant改为`Random Between Two Constants`。常量代表的是使用的资源索引。

如果不想要粒子在播放中更换图片资源，则需要将FrameOverTime的动画曲线设置为水平点，即删除线段末尾的关键帧点。

想要设置粒子系统的基础属性，则可以点击`ParticleSystem`打开属性栏。

**启动寿命（Start Lifetime）**：一个粒子的寿命是它在被粒子系统破坏之前在屏幕上的时间。如果在场景视图中缩小，将看到所有粒子在同一个位置周围消失。因为粒子以相同的速度和寿命开始，它们最终在相同的距离被摧毁。单击“开始生存期”右侧的小向下箭头，可以在两个常量之间选择随机产生数值。

**开始大小（Start Size）**：粒子创建时的大小。

**开始速度（Start Speed）**：粒子开始移动的速度。

**Size Over Lifetime**：随着生命周期粒子大小的改变。

**Color Over Lifetime**：随着生命周期粒子颜色的改变。

在粒子系统基础属性里，将Simulation Space的值从Local改为world，粒子就不会跟随游戏物体进行移动了。

 想要在一段时间爆发产生大部分粒子可以使用`Emission`属性。

### 3.UGUI

用于玩家观察掌握操作角色的关键数值（hp，mp...）

Unity中的UI必须使用画布（Canvas）组件来对其进行渲染，画布定义了每个UI元素在屏幕上的呈现方式，并负责呈现它的所有子UI组件。

**事件系统(EventSystem)**：创建画布的时候会同时创建，来处理事件和与UI的交互，比如鼠标点击。

**Canvas组件中的RenderMode（渲染模式）**：

屏幕空间-覆盖（Screen Space-Overlay）：这个默认模式使Unity一直在游戏顶部绘制用户界面。大多数应用程序使用此模式是因为它们希望UI始终位于最上面，以提供所有信息。（最常用）

屏幕空间-相机（Screen Space-Overlay）：这将在与相机对齐的平面上绘制用户界面。该平面的大小将始终填充屏幕，因此可以四处移动相机，并且该平面将与相机一起移动，以显示与覆盖相同的效果。但是，因为平面是在世界上绘制的，而不是在屏幕上，所以世界上的对象可以在用户界面上绘制。（也就是说一些游戏物体可能会覆盖UI）

世界空间（World Space）：这将在世界任何地方绘制一个平面。可以将此平面用作游戏中计算机的屏幕、墙壁或角色的顶部。（比如制作血条）

画布缩放器组件（Canvas Scaler）：该组件定义UI如何根据不同屏幕大小进行缩放。



**UI的缩放模式（UI Scale Mode）**：

恒定大小（Constant Pixel Size or Constant Physical Size）：这使得UI保持相同恒定不变的大小，无论屏幕是什么大小或形状。这使得UI在任何屏幕上都保持可读性，但是较小的屏幕可能有很大的UI覆盖空间，如果屏幕太小，UI元素可能会重叠。

按屏幕大小缩放（Scale With Screen Size）：按屏幕大小缩放：这使得UI的缩放取决于开发者设置为参考分辨率的屏幕大小。

选中Image，点击组件中的Set Native Size按钮可以使图片保持原本大小。

选中矩形变换工具（快捷键T），按住shift键点击四角的蓝点可以等比缩放图片大小。



锚点可以保证当前UI的轴心点与锚点之间的距离保持不变，可以通过调整锚点的值来做UI的自适应。使用自定义锚点可以使图片基于父对象等比进行缩放。



不规则图形的填充可以使用mask组件，父对象UI需要挂载mask组件，子对象则为具体填充UI。

想要百分比填充UI，首先需要获取到mask组件的width属性（轴心点要设置为左上），设置血条填充百分比可以使用mask.rectTransform.SetSizeWithCurrentAnchors方法去设置。

想要全局访问某一个变量的方法或者成员变量可以使用单例模式。

### 4.NPC对话

可以在npc附近设置触发器，进入范围就可以按下对应按键进行对话

更便利的是在操作角色的脚本上编写一个射线检测功能，用于判断当前面对的一定范围内的物体是否为npc，若是，则按下对应键执行对话。

（）2

### 5.音乐与音效添加

**音频剪辑资源（AudioClip）**：音频剪辑是资源，如纹理或脚本。可以从音频文件（如mp3、ogg和wav文件）中导入音频片段。

**音频监听器（AudioListener）**:音频侦听器是定义“侦听器”在场景中的位置的组件。用来接收音频资源的播放，在使用空间化声音时非常有用。场景中有且仅需要一个。

**音频源（AudioSouce）**:音频源是一个组件，允许在组件所在的GameObject位置播放音频剪辑。

如果想要音乐循环播放需要勾上AudioSouce组件上的**Loop**属性。

如果希望游戏运行后播放音乐需要勾上**PlayOnAwake**选项。

volume控制音量大小。Spatial Blend控制音乐播放方式为2D还是3D。

音效的播放可以使用AudioSouce组件的`PlayOneShot`方法。

使用随机数可以使用`Random.Range（a,b）`方法，如果a,b为整数int，则随机数包含a,不包含b，如果是浮点数，则左右都包含。

如果想要播放持续音效，可以直接调用`audioSouce.Play（）`，停止则可以使用`audioSouce.Stop（）`，是否正在播放状态的判断可以使用`audioSouce.isplaying`

### 6.打包

在`Edit > Build Settings`中进行打包。

打包界面有如下几个参数：

* 公司名称（Company Name）：用于创建将要存储游戏中创建的文件的文件夹，或其他与系统相关的文件。

* 产品名称（Product Name）：游戏或应用程序名称。这将用于命名可执行文件/包（取决于平台），并在公司名称下创建一个位置，以保存与该游戏相关的所有内容。

* 默认图标（Default Icon）:即应用程序的图标，例如移动设备上的应用程序图标和桌面上的可执行图标。

* 默认鼠标指针样式（Default Cursor）:可以将其设置为具有不同于系统默认箭头的光标。

打包期间，不能在Unity编辑器中执行任何其他操作，因为Unity正在压缩和打包的所有资源，检测并忽略未使用的资源，将脚本编译为优化的表单和其他小任务，所有这些都是为了减少游戏占用的空间并使其访问数据更快。

每次更改源文件后都要重新找一个位置打包。

























